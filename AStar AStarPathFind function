IEnumerator AStarPathFind(Vector3 rootNodePos, Vector3 goalNodePos)
{
    /*//////////////////////////////////////////////////
    

    //        THIS FUNCTION IS INCOMPLETE
    //        Use the comments to determine the missing line of code.


    //////////////////////////////////////////////////*/



    //Declared to avoid errors
    Node rootNode = null;
    Node goalNode = null;

    //Get the root node and set it to rootNode
    rootNode = NodePositionInGrid(rootNodePos);

    //Get the goal node and set it to goalNode
    goalNode = NodePositionInGrid(goalNodePos);

    //Create a new List<Node> set for open nodes
    openSet = new List<Node>();

    //Create a new List<Node> set for closed nodes
    closedSet = new List<Node>();

    //has path been found?
    pathFound = false;

    //add root node to the open set
    openSet.Add(rootNode);

    //create a current node variable
    currentNode = new Node(Vector3.zero, false, -1, 1);


    ////// IGNORE - UI STUFF /////
    if (!rootNode.traversable || !goalNode.traversable)
    {
        //is it searching
        searching = false;
    }
    else
    {
        searching = true;
    }
    //////////////////////////////


    // while there are still nodes in the open set
    while (openSet.Count > 0 && !pathFound && searching)
    {

        /////// IGNORE - UI STUFF /////////////
        if (pause)
        {
            yield return null;
        }
        else
        {
            if (!dynamicMode)
            {
                yield return new WaitForSeconds(searchSpeed);
            }
            ///////////////////////////////////////


            //Set the first node from the list to current node
            currentNode = openSet[0];

            //we check the rest of the nodes 
            for (int i = 1; i < openSet.Count; i++)
            {
                //if the node has less fCost than the current node, or the same but less Hcost
                if (openSet[i].f < currentNode.f || openSet[i].f == currentNode.f && openSet[i].h < currentNode.h)
                {
                    currentNode = openSet[i];
                }
            }

            //as we are checking current node, remove the currnet node from the open set
            openSet.Remove(currentNode);

            //put it into the closed set
            closedSet.Add(currentNode);


            //if its the goal node, we are done
            if (currentNode == goalNode)
            {
                //retrace the path from root to goal;
                RetracePath(rootNode, goalNode);
                //Path is found
                pathFound = true;
                //No Longer Searching
                searching = false;

                //////////////  IGNORE - UI STUFF////////////////////////////
                startStopSearchButton.gameObject.transform.Find("Text").GetComponent<Text>().text = "Start";
                ///////////////////////////////////////////////////
            }
            else
            {
                //For each neighbour of the current node
                foreach (Node neighbour in GetNeighbours(currentNode))
                {
                    //if we cannot traverse to the neighbour, or is in the close set
                    if (!neighbour.traversable || closedSet.Contains(neighbour))
                    {
                        //skip this loop
                        continue;
                    }

                    //Calculate the move to neightbor gCost using Hueristic (use getdistance)
                    float newMoveCost = -1;

                    //if the new move costs less or this neighbour isnt in the open set
                    if (newMoveCost < neighbour.g || !openSet.Contains(neighbour))
                    {
                        //store (new) move cost
                        neighbour.g = newMoveCost;
                        //store heuristic to goalNode

                        neighbour.h = GetDistance(neighbour, goalNode);

                        //store parent
                        neighbour.parentNode = currentNode;

                        //if we dont have this neighbour in the open set
                        if (!openSet.Contains(neighbour))
                        {
                            openSet.Add(neighbour);
                        }

                    }
                }
            }


            /////// IGNORE /////////////////
            if (step)
            {
                step = false;
                pause = true;
                GameObject.Find("PauseBtn").gameObject.transform.Find("Text").GetComponent<Text>().text = "Play";
            }
            ///////////////////////////////
        }
    }
    searching = false;
}
